WIP

In this chapter, we will quickly setup a Fashion Store app, in order to focus on more advanced topics, such as:

    Babel
    Linting
    Tests
    SSR
    i18n
    Deployment


The app will be a simple wearable online shop:

screenshot
Advanced development workflow

In this first section, we will improve our development workflow with new tools and packages. But first, we need to setup our Fashion Store project.
Project setup

This time we will use a full project template generated using the vue init command. We will use the webpack-simple official template into a new e-shop folder:

vue init webpack-simple e-shop

This project template features a ready-to-use minimal webpack configuration that we will extend in this chapter.

Answer the questions of vue-cli like this:

? Project name e-shop
? Project description An e-commerce app
? Author Your Name <your-mail@mail.com>
? Use sass? No

Then go to the newly created e-shop folder and install the default dependencies already declared in the package.json file (like vue and webpack):

cd e-shop
npm install

We will also install stylus:

npm i -D stylus stylus-loader

Now download the sources files [here] and extract them in a new src folder. Those contains all the app source code already done so we can move forward faster. We need to install a few more packages in the dependencies though:

npm i -S axios vue-router vuex vuex-router-sync

axios is a great library for making requests to the server and is recommended by the Vue.js team!
Generating a quick development API

Previously, we had a full node server for the backend, but this time we will not focus on the app features. So we will use the json-server package to generate a very simple local API for the purpose of this chapter. Install it as a dev dependency:

npm i -D json-server

When will run this package, it will locally expose a simple REST API and use a db.json file to store the data. You can download it [here] and put it in the project root directory. If you open it, you will see a few items for sale and a comment.

Then, we need to add a script to launch the json server. Add a new db script to the package.json file:

"db": "json-server --watch db.json"

This command will run the json-server package command-line tool and watch the db.json file you just downloaded for changes so you can edit it easily. To try it, use npm run:

npm run db

By default it will listen to the port 3000. You can already try it by opening the http://localhost:3000/items REST address in your browser:

screenshot
Configuring babel

As a reminder, babel is the tool that compiles our JavaScript code so we can use new features in older and current browsers (like JSX or arrow functions).

By default, the webpack-simple template comes with a default babel configuration that uses the env babel preset which supports all the stable JavaScript version from ES2015. But the source code we downloaded earlier contains some new JavaScript syntax, so we need to install another babel preset called stage-0 which supports the upcoming JavaScript features like the async/await keywords.

We also need to include the polyfills provided by babel so new features like Promise and generators work in older browsers.
A polyfill is a code that checks if a feature is available in the browser, and if not it implements this feature so it works like is is native.
Stage 0 preset

So first we need to install this new preset in the dev dependencies:

npm i -D babel-preset-stage-0

The main babel configuration is done in the .babelrc json file already present in the project root.
This file may be hidden in your file explorer, depending on the system. However it should be visible in your code editor if it has a file tree view.

Open this .babelrc file and add the stage-0 preset to the corresponding list:

{
  "presets": [
    ["env", { "modules": false }],
    "stage-0"
  ]
}

Polyfills

Install the babel-polyfill package in your dev dependencies:

npm i -D babel-polyfill

Then, import it at the beginning of the src/main.js file:

import 'babel-polyfill'

This will enable all the necessary polyfills for the browser.
Launching the app

We are now ready to start the app! Open a new terminal and use npm run as usual:

npm run dev

It should open a new browser window with the right address and you should be able to use the app:

screenshot
Auto-prefixing CSS with PostCSS

When writing CSS (or Stylus) code, we want it to be compatible with most browsers. Fortunately, there are tools that will do this automatically for us, for example by adding vendor prefixed versions of the CSS properties (like -webkit-user-select and -moz-user-select).

PostCSS is a library specialized in CSS post-processing. It has a very modular architecture: it works by adding plugins to it that process the CSS in various ways.

We don't have to install it: vue-loader already have PostCSS included! We only have to install the plugins we want. In our case, we need the autoprefixer package, to make our CSS code compatible with more browsers:

npm i -D autoprefixer

For PostCSS to be active, we need to add a configuration file called postcss.config.js in the project root directory. Let's tell PostCSS we want to use autoprefixer in this file:

module.exports = {
  plugins: [
    require('autoprefixer'),
  ],
}

That's it! Our code is now processed by autoprefixer. For example, take this Stylus code:

.store-cart-item
  user-select none

The final CSS will be:

.store-item[data-v-1af8c5dc] {
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

Targeting specific browsers with browserslist

We can change what browsers are targeted by autoprefixer with the browserslist configuration. It consists of a list of rules to determine which browsers to support. Create a new browserslist file (without extension) in the project root directory, and put the default values which are the following:

> 1%
last 2 versions
Firefox ESR

The first rule takes the browsers that have more than 1% of usage share on the Internet. The second one additionally selects the last two versions of every browsers. Finally, the special 'ESR' version of Firefox is also selected.
The data used is provided by the caniuse.com site, which is specialized in browser compatibility data.

You can now target even older browsers by customizing this file! For example, to target Firefox 20 and up, you would add the following rule:

Firefox >= 20

You can find more information about browserslist on its GitHub repository.
Improving code quality and style with ESLint

Enforcing good coding practices and quality is essential when working on a project with other developers. It ensures no syntax and basic errors are made, and it helps keeping the source code clean and consistent. This process is called 'linting'.

ESLint is the recommended linting tool by the Vue.js team. It provides a set of linting rules that can be turned on and off to check the code quality. More rules can be added by plugins and some packages define a preset of enabled rules.

We will use the StandardJS preset and the eslint-plug-vue package which adds more rules that help follow the official Vue style guide:

npm i -D eslint eslint-config-standard eslint-plugin-vue@beta

The eslint-config-standard package has 4 peer dependencies we need to install as well:

npm i -D eslint-plugin-import eslint-plugin-node eslint-plugin-promise eslint-plugin-standard

In order to use Babel for the JavaScript code when ESLint parses the files, we need an additional package:

npm i -D babel-eslint

Configuring ESLint

Create a new .eslintrc.js file in the project root directory and write the following configuration:

module.exports = {
  // Use only this configuration
  root: true,
  // File parser
  parser: 'vue-eslint-parser',
  parserOptions: {
    // Use babel-eslint for JavaScript
    'parser': 'babel-eslint',
    'ecmaVersion': 2017,
    // With import/export syntax
    'sourceType': 'module'
  },
  // Environment global objects
  env: {
    browser: true,
    es6: true,
  },
  extends: [
    // https://github.com/feross/standard/blob/master/RULES.md#javascript-standard-style
    'standard',
    // https://github.com/vuejs/eslint-plugin-vue#bulb-rules
    'plugin:vue/recommended',
  ],
}

First, we use the vue-eslint-parser to read the files (including the .vue files). It uses babel-eslint when parsing the JavaScript code. We also specify the EcmaScript version of JavaScript, and that we use the import/export syntax for the modules.

Then we tell ESLint that we expect to be in a browser and ES6 (or ES2015) JavaScript environment, which means we should be able to access globals like window or Promise without ESLint raising undefined variable errors.

We also specify which configurations (or presets) we would like to use: standard and vue/recommended.
Customizing the rules

We can change what rules are enabled and modify their options with the rules object. Add the following to the ESLint configuration:

rules: {
  // https://github.com/babel/babel-eslint/issues/517
  'no-use-before-define': 'off',
  'comma-dangle': ['error', 'always-multiline'],
},

The first line disables the no-use-before-define rule which has a bug when using the ... destructuration operator. The second one change the commad-dangle rule to enforce putting a trailing , comma at the end of all the array and object lines.
The rules have a status which can take on those three values: 'off' (or 0), 'warn' (or 1) and 'error' (or 2).
Running ESLint

To run eslint on the src folder, we need a new script in the package.json:

"eslint": "eslint --ext .js,.jsx,.vue src"

You should see some errors in the console:

screenshot

Some of those issues can be fixed by ESLint by adding the --fix argument to the eslint command above:

"eslint": "eslint --ext .js,.jsx,.vue src --fix"

Run it again and you should see only one error remaining:

screenshot

ESLint tells us we shouldn't create new objects without keeping their reference in a variable. If we look at the corresponding code, we see that we indeed create a new instance of Vue in the main.js file:

new Vue({
  el: '#app',
  router,
  store,
  ...App,
})

If you look at the ESLint error, you can see the code of the rule: no-new. You can open the eslint.org website and type it in the search field to get the rule definition. If its a rule added by a plugin, it should have the name of the plugin followed by a slash. For example: vue/require-v-for-key.

This code is written as intended, since this is the standard way of declaring a Vue app. So we need to disable this rule for this specific line of code, by adding a special comment just before:

// eslint-disable-next-line no-new
new Vue({
  ...
})

ESLint inside Webpack

For now, we have to manually run the eslint script to check our code. It would be even better if we were able to check our code when it is processed by Webpack, so it would be fully automatic. Fortunately, this is possible thanks to the eslint-loader! Install it in the dev dependencies alongside the friendly-errors-webpack-plugin package which will improve the console messages:

npm i -D eslint-loader friendly-errors-webpack-plugin

Now we have to change the webpack configuration to add a new ESLint loader rule. Edit the webpack.config.js file and add this new rule at the top of the module.rules option:

module: {
  rules: [
    {
      test: /\.(jsx?|vue)$/,
      loader: 'eslint-loader',
      enforce: 'pre',
    },
    // ...

Additionally we can enable the friendly-errors-webpack-plugin package. Import it at the top of the file:

const FriendlyErrors = require('friendly-errors-webpack-plugin')

We can't use the import/export syntax here, since it will be executed in nodejs.
Then, add this plugin when we are in development mode, by adding an else condition at the end of the configuration file:

} else {
  module.exports.plugins = (module.exports.plugins || []).concat([
    new FriendlyErrors(),
  ])
}

Restart webpack by re-running the dev script, and remove a comma somewhere in the code. You should see the ESLint error displayed in the webpack output:

screenshot

In the browser, you should now see the error overlay:

screenshot

If you fix the error by putting the comma back again, the overlay will close and the console will display a friendly message:

screenshot
Unit Testing with Jest

Important code and components should be unit tested to be sure they are working as intended and to prevent most regressions when the code evolves. The recommended test runner for Vue components is Jest from Facebook. It is quite fast with a cache system, and has an handy snapshot feature to help detect regressions even more.

First, install Jest and the official Vue unit testing tools:

npm i -D jest vue-test-utils

We also need a few utilities related to Vue, to compile the .vue files with vue-jest and to take snapshots of the components:

npm i -D jest-vue jest-serializer-vue vue-server-renderer

The recommended way to get the HTML render of a component in node is using the vue-server-renderer package used to do Server-Side Rendering as we will see later in the chapter.

Finally, we need some babel packages to support babel compilation and webpack dynamic imports inside Jest:

npm i -D babel-jest babel-plugin-dynamic-import-node

Configuring Jest

To configure Jest, let's create a new jest.config.js file in the project root directory:

module.exports = {
  transform: {
    '.+\\.jsx?$': '<rootDir>/node_modules/babel-jest',
    '.+\\.vue$': '<rootDir>/node_modules/jest-vue',
  },
  snapshotSerializers: [
    '<rootDir>/node_modules/jest-serializer-vue',
  ],
  mapCoverage: true,
}

The transform options define processors for the JavaScript and Vue files. Then we tell Jest to use jest-serializer-vue for serializing the snapshots of the components. We also enable the source maps with the mapCoverage option.

You can find more configuration options on the Jest website.
Babel configuration for Jest

To support JavaScript import/export modules and dynamic imports inside Jest, we need to change our babel configuration when the tests are run.
When using Jest, we are not using webpack and the loaders we use to build the real application.
We need to add two babel plugins to the configuration, when the NODE_ENV environment variable is set to 'test':

{
  "presets": [
    ["env", { "modules": false }],
    "stage-0"
  ],
  "env": {
    "test": {
      "plugins": [
        "transform-es2015-modules-commonjs",
        "dynamic-import-node"
      ]
    }
  }
}

The transform-es2015-modules-commonjs plugin add support of import/export syntax to Jest, and the dynamic-import-node adds support for dynamic imports.
When run, Jest will automatically set the NODE_ENV environment variable to 'test'.
Our first Unit Test

To be recognized by Jest anywhere by default, we need to call our test files .test.js or .spec.js. We will test the BaseButton.vue component, so go ahead and create a new BaseButton.spec.js file next to it in the src/components folder. First we will import the component and the shallow method from vue-test-utils:

import BaseButton from './BaseButton.vue'
import { shallow } from 'vue-test-utils'

Then we create a tests suite with the describe function:

describe('BaseButton', () => {
  // Tests here
})

Inside the tests suite, we can add our first unit test with the test function:

describe('BaseButton', () => {
  test('click event', () => {
    // Test code
  })
})

We will test if the click event is emitted when we click on the component. We need to create a wrapper object around the component that will provide useful functions to test the component:

const wrapper = shallow(BaseButton)

Then, we simulate a click on the component:

wrapper.trigger('click')

Finally, we check if the click event was emitted using the Jest expect method:

expect(wrapper.emitted().click).toBeTruthy()

Now, let's add a script in the package.json file to run Jest:

"jest": "jest"

Then, using the usual npm run command:

npm run jest

The tests are launched and should pass:

screenshot

To learn more about unit testing Vue components, you can visit the official guide at vue-test-utils.vuejs.org.
ESLint and Jest globals

If we run ESLint now, we will get errors related to the Jest keywords like describe, test and expect:

screenshot

We need to make a tiny change to our ESLint configuration: we have to specify the jest environment. Edit the .eslintrc.js file:

// Environment global objects
env: {
  browser: true,
  es6: true,
  jest: true,
},

Now ESLint will know about the Jest keywords and will stop complaining!
Jest Snapshots

Snapshots are strings that are saved and compared each time tests are run, to detect potential regression. They are mostly used to save the HTML render of component, but can be used for any value as long as it make sens to store it between tests and compare it.

For our Vue component, we will snapshot the HTML render of it using the Server-Side Rendering tool called vue-server-renderer. We need the createRenderer method from this package:

import { createRenderer } from 'vue-server-renderer'

At the start of the test, we instanciate a renderer instance, then we wrap the component with shallow and start rendering the component to a String. Finally, we compare the result with the previous one. Here is an example of snapshot test for the BaseButton component, passing some props values and the default slot content:

test('snapshot', () => {
  const renderer = createRenderer()
  const wrapper = shallow(BaseButton, {
    // Props values
    propsData: {
      icon: 'add',
      disabled: true,
      badge: '3',
    },
    // Slots content
    slots: {
      default: '<span>Add Item</span>',
    },
  })
  renderer.renderToString(wrapper.vm, (err, str) => {
    if (err) throw new Error(err)
    expect(str).toMatchSnapshot()
  })
})

If the snapshot test is run for the first time, it will create and save the snapshot into a __snapshots__ folder next to it. If you are using a versioning system like git, you need to add these snapshot files to it.
Updating the snapshots

If you modify a component, there are chances that its HTML render will change too. This means its snapshots will no longer be valid and the Jest tests will fail. Fortunately, the jest command has a --updateSnapshots argument. When used, all the failing snapshots will be re-saved and will pass.

Let's add a new script in our package.json file:

"jest:update": "jest --updateSnapshot

Modifiy the BaseButton component by changing a CSS class for example. if your run the Jest tests again, you should get an error: the snapshots don't match anymore.

screenshot

Now update the snapshot with the new script:

npm run jest:update

All the tests should pass now, and the BaseButton snapshot should be updated:

screenshot
You should run this command only when you are sure there are no gregressions elsewhere. A good idea is to run the tests normally just before, to make sure only the modified component snapshot fails, as expected. After you have updated the snapshots, use the normal test command.
Complementary Topics

In this section, we will cover a few more topics that can be usefull for bigger apps.
Internationalization & Code-splitting

If the app is to be used by people in different countries, it should be translated to be more user-friendly and appealing. To localize the texts of the app, you can use the recommended vue-i18n package:

npm i -S vue-i18n

Using vue-i18n, we will add a link in the AppFooter component to a new page where the user can select the language. Only the link and this page will be translated, but you can translate more parts of the app if you wish. vue-i18n works by creating a i18n object from it with the translated messages, and injecting it into the Vue app.

In the src/plugins.js file, install the new plugin into Vue:

import VueI18n from 'vue-i18n'

// ...

Vue.use(VueI18n)

Let's create a new folder called i18n in the project directory. Download the locales folder containing the translation files and put it inside. You should have for example the en translations in the i18n/locales/en.js file.

Create a new index file that exports the list of available languages:

export default [
  'en',
  'fr',
  'es',
  'de',
]

We need two new utility functions:

    createI18n to create the i18n object, with a locale parameter.
    getAutoLang that returns the two-letter language code set by the user in the browser, for example en or fr. Most of the time, this will be his OS language setting.

In the src/utils folder, create a new i18n.js file and import both VueI18n and the list of available locales we defined earlier:

import VueI18n from 'vue-i18n'
import langs from '../../i18n'

Code-splitting with dynamic imports

When we create the i18n object, we want to load only the translations of the selected locale via the locale argument. To do that, we will make a dynamic import of the file with the import function. It takes the path as the argument, and returns a Promise which will eventually resolve to the corresponding JavaScript module once it is loaded from the server. In webpack, this dynamic import feature is sometimes refered as 'code splitting', because webpack will move the asynchronous module to another compiled JavaScript file called a chunk.

Here is an example of an asynchronous module loaded with a dynamic import:

async function loadAsyncModule () {
  await module = await import('./path/to/module')
  console.log('default export', module.default)
  console.log('named export', module.myExportedFunction)
}

You can use variables in the imported path, as long as it is has some information about where webpack can find the files. For example, this code will not work:

import(myModulePath)

But this one will work fine as long as the variable path is simple (without ../):

import(`./data/${myFileName}.json`)

In this example, all the files with the json extension in the data folder will be added to the build into asynchronous chunks, because webpack can't guess which ones you will really use at runtime.

Asynchronously loading big JavaScript modules with dynamic imports can reduce the size of the initial JavaScript code send to the browser when opening the page. In our app, it allows us to load only the relevant translations file instead of including them all in the initial JavaScript file.
If a module is already imported with a normal import in the main code (the initial chunk), it will already be loaded and will not be split into another chunk. In that case, you won't have the benefits of the code-splitting feature and the initial file size won't be reduced. Note that you can synchronously use other modules with the normal import keyword inside the dynamically loaded module: they will be put together in the chunk (if they aren't already included in the initial chunk).

The i18n object is created with the VueI18n constructor from the vue-i18n package. We will pass the locale argument and

Here is what the createI18n function should look like:

export async function createI18n (locale) {
  const { default: localeMessages } = await import(`../../i18n/locales/${locale}`)
  const messages = {
    [locale]: localeMessages,
  }

  const i18n = new VueI18n({
    locale,
    messages,
  })

  return i18n
}

As you can see, we need to take the default value of the module, because we exported the messages using export default.

The code using async/await above can be written using Promises that way:

export function createI18n (locale) {
  return import(`../../i18n/locales/${locale}`)
    .then(module => {
      const localeMessages = module.default
      // ...
    })
}

Automatically loading the user locale

Next, we can use the navigator.language (or userLanguage for Internet Explorer compatibility) to retrieve the locale code. Then we check if it is available in the langs list or we use the default en locale. The getAutoLang function should look like this:

export function getAutoLang () {
  let result = window.navigator.userLanguage || window.navigator.language
  if (result) {
    result = result.substr(0, 2)
  }
  if (langs.indexOf(result) === -1) {
    return 'en'
  } else {
    return result
  }
}

Some browsers may return the code in the en-US format, but we only need the first two characters.

In the src/main.js file, import the two new utility functions:

import { createI18n, getAutoLang } from './utils/i18n'

Then, modify the main function:

    Retrieve the preferred locale using getAutoLang.
    Create and wait for the i18n object with the createI18n function.
    Inject the i18n object into the root Vue instance.

It should now look like this:

async function main () {
  const locale = getAutoLang()
  const i18n = await createI18n(locale)
  await store.dispatch('init')

  // eslint-disable-next-line no-new
  new Vue({
    el: '#app',
    router,
    store,
    i18n, // Inject i18n into the app
    ...App,
  })
}

Don't forget the await keyword in front of createI18n, or else you will get the Promise instead.

You can now open the network pane in the browser devtools and refresh the page. The translations module corresponding to the selected locale will be loaded by webpack in a separate request. In this example screenshot, this is the 2.build.js file which is asynchronously loaded:

screenshot
Change Language page

For now, nothing really changed in the app, so let's add the page which will allow us to select the language. In the src/router.js file, import the PageLocale component:

import PageLocale from './components/PageLocale.vue'

Then add the locale route in the routes array, just before the last one (with the * path):

{ path: '/locale', name: 'locale', component: PageLocale },

In the AppFooter.vue component, add this router link to the template:

<div v-if="$route.name !== 'locale'">
  <router-link :to="{ name: 'locale' }">{{ $t('change-lang') }}</router-link>
</div>

As you can see, we use the $t provided by vue-i18n to display a translated text. The argument correspond to the key in the locale file.You should now see the link in the app footer:

screenshot

The links takes to the language selection page which is already fully translated using vue-i18n:

screenshot

You can look at its source code in the components/PageLocale.vue file.

When you click on a locale button, the corresponding translations are loaded if they aren't alreay. In the network pane of the browser devtools, you should see a request made to other chunks each time:

screenshot
Server-Side Rendering

Server-Side Rendering (or SSR) consists of running and rednering the app on the server, before sending the HTML back to the browser. This as two main advantages:

    Better Search Engine Optimization (or SEO), since the initial content of the application will be rendered in the page HTML. This is important since no search engine is indexing asynchrous JavaScript app (for example when you have a spinner).
    Slower networks or devices will display contents faster: the rendered HTML doesn't need the JavaScript to be shown to the user.

But using SSR also bring some trade-offs:

    The code need to be able to run on the server (unless it is in client-side only hooks like mounted). Also, some libraries may not play well on the browser and may require special treatments.
    The load with increase on the server, since it is dowing more work.
    The development setup is a bit more complex.

So using SSR isn't always a good idea, especially if the time the first content is shown isn't critical (for example, an admin dashboard).
Universal App Structure

Writting an Universal App that runs both on the client and the server requires to change the architecture of the source code.

When running on the client, we are in a fresh context each time the page is loaded. That's why we used singletons instance of the root instance, the router and the store until now. But now we need to have a fresh context on the server as well: the problem is, nodejs is statefull! The solution is creating a fresh new root instance, router and store for each request handled by the server.

Let's start with the router! In the src/router.js file, wrap the router creation into a new exported createRouter function:

export function createRouter () {
  const router = new VueRouter({
    routes,
    mode: 'history',
    scrollBehavior (to, from, savedPosition) {
      // ...
    },
  })

  return router
}

We will do the same with the Vuex store. In the src/store/index.js file, wrap the code into a new exported createStore function:

export function createStore () {
  const store = new Vuex.Store({
    strict: process.env.NODE_ENV !== 'production',

    // ...

    modules: {
      cart,
      item,
      items,
      ui,
    },
  })

  return store
}

Let's also rename the src/main.js file to src/app.js. This will be our universal file that creates the router, the store and the Vue root instance. Change the main function into an exported createApp function which takes a context argument and returns the app, the router and the store:

export async function createApp (context) {
  const router = createRouter()
  const store = createStore()

  sync(store, router)

  const i18n = await createI18n(context.locale)
  await store.dispatch('init')

  const app = new Vue({
    router,
    store,
    i18n,
    ...App,
  })

  return {
    app,
    router,
    store,
  }
}

Don't forget to change the imports for createRouter and createStore!

On the server, we won't select the initial locale the same way than in the client since we won't have access to window.navigator. That's why we are passing the locale in the context argument:

const i18n = await createI18n(context.locale)

We also removed the el option from the root instance definition since it doesn't make sense on the server.
Client entry

Create a new src/entry-client.js file that will be the entry point for the client bundle. It will get the user language, call the createApp function and then mount the app into the page:

import { createApp } from './app'
import { getAutoLang } from './utils/i18n'

const locale = getAutoLang()
createApp({
  locale,
}).then(({ app }) => {
  app.$mount('#app')
})

You can now change the entry path in the webpack.config.js file:

entry: './src/entry-client.js',

You can restart the dev script and check that the app still works in the browser.
Server entry

Create a new src/entry-server.js file that will be the entry point for the server bundle. It will export a function that gets a context object from the HTTP server we will build later. It should return a Promise that resolves with the Vue app when it's ready.

We will pass an url attribute to the context so we can set the current route like this:

router.push(context.url)

Similarly to the client entry, we also use the createApp function to create the root app instance, the router and the store. The entry-server.js should look like this:

import { createApp } from './app'

export default context => {
  return new Promise(async (resolve, reject) => {
    const { app, router, store } = await createApp(context)
    // Set the current route
    router.push(context.url)
  })
}

The app root instance will be send back to what we call the renderer (kind of like when we did Jest snapshots).
State management

When processing a request, we need to fetch the data on the relevant components before rendering the app. That way, the data will already be displayed when the HTML is loaded by the browser! For example, PageHome.vue fetches the store items and PageStoreItem.vue retrieves the item details and comments.

We will add a new asyncData custom option to those, so we can call it on the server when doing SSR. Edit the PageHome.vue component by adding this function that dispatches the fetchItems action of the items store module:

asyncData ({ store }) {
  return store.dispatch('items/fetchItems')
},

In the PageStoreItem.vue component, we need to call the fetchStoreItemDetails action of the item store module, with the id parameter of the route passed by the server:

asyncData ({ store, route }) {
  return store.dispatch('item/fetchStoreItemDetails', {
    id: route.params.id,
  })
},

Now that our components are ready, back to entry-server.js. We can use the router.getMatchedComponents() method to get the list of components that matched with the current route:

router.push(context.url)

router.onReady(() => {
  const matchedComponents = router.getMatchedComponents()

}, reject)

We can then call all the asyncData options of these components and wait for them to finish. We pass both the store and the current route to them, and when they have all completed, we send the Vuex store state back to the renderer with context.state = store.state. Use Promise.all(array) to wait for all the asyncData calls:

const matchedComponents = router.getMatchedComponents()

Promise.all(matchedComponents.map(Component => {
  if (Component.asyncData) {
    return Component.asyncData({
      store,
      route: router.currentRoute,
    })
  }
})).then(() => {
  // Send back the store state
  context.state = store.state

  // Send the app to the renderer
  resolve(app)
}).catch(reject)

If an error occurs, it will reject the Promise we returned to the renderer.
Webpack configuration

Our app code is now ready! Before continuing, we need to refactor our webpack configuration.

We will need a slightly different webpack configuration for the client and the server. It is a good idea to have a common configuration file, which is then extended for the client and the server. We can do this easily with the webpack-merge package that merges multiples webpack configuration objects into one.

For the server configuration, we also need the webpack-node-externals package to prevent webpack from bundling the packages in node_modules: this is not necessary since we will run inside nodejs and not in the browser. All the corresponding imports will be left as require statements so that node will load them itself.

Install the packages in the dev dependencies:

npm i -D webpack-merge webpack-node-externals

Create a new webpack folder in the project root directory, then move and rename the webpack.config.js file to webpack/common.js. Some changes are needed:

1. Remove the entry option from the configuration. This will be specified in the specific extended configurations.

2. Update the output option to target the correct folder and to generate better chunk names:

output: {
  path: path.resolve(__dirname, '../dist'),
  publicPath: '/dist/',
  filename: '[name].[chunkhash].js',
},





Server-side setup

In development, we can't use webpack-dev-server directly anymore with SSR. Instead, we will setup the express server with webpack. Download the server.dev.js file and put it in the project root directory. This file exports a setupDevServer function that we will use to run webpack and update the server.

We will also need some packages for the development setup:

npm i -D memory-fs chokidar webpack-dev-middleware webpack-hot-middleware

We can create virtual file systems with memory-fs, watch files with chokidar and enable webpack Hot Module Replacement in an express server with the last two middlewares.
Page template

Create a new index.template.html file alongside index.html and copy its contents. Then replace the body content with the special <!--vue-ssr-outlet--> comment:

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Fashion Store</title>
  </head>
  <body>
    <!--vue-ssr-outlet-->
  </body>
</html&gt;

This special comment will be replaced by the rendered markup on the server.
Express server

On the nodejs side, we will use the express package to create our HTTP server:

npm i -S express






To continue learning about SSR, you can visit the official documentation at ssr.vuejs.org or use an easy-to-use framework called nuxtjs which abstracts a lot of boilerplate away from you.
Production & Deployment


npm run build




Summary
